/*
 * @File: SB-SBL Syntax Converter.ahk2
 * @Author: Aldrin John O. Manalansan (ajom)
 * @Email: aldrinjohnolaermanalansan@gmail.com
 * @Brief: Convert Source Codes from Legacy SB Syntax into SBL Syntax
 * @Last Update: June 2, 2025
 */

#Requires AutoHotkey v2
#include %A_MyDocuments%/AutoHotkey/Lib/v2
#SingleInstance Ignore ; Don't rerun itself
#Warn ; Enable warnings to assist with detecting common errors
#NoTrayIcon
KeyHistory 0 ; no key logging
ListLines False ; unload line logging
SetWorkingDir A_ScriptDir ; Ensures a consistent starting directory

; #region ~~~~~~~~~~~~~~~~~~~ INITIALIZATION ~~~~~~~~~~~~~~~~~

; #region Constants
AppVersion := { Major: 1, Minor: 3, Patch: 1 }
AppName := "AJOM's SB->SBL Syntax Converter"
Gui_ControlPanel_DefaultTitle := AppName . " v" . AppVersion.Major . "." AppVersion.Minor . "." AppVersion.Patch . (A_IsAdmin?" (Administrator)":"")
INIPATH := A_ScriptDir . "\" . "Settings.ini"

GUIFONTNAME := "Consolas"
GUIFONTSIZE := 10
GUITEXTCOLOR := "FFFFFF"
GUIBACKGROUND := "303841" ; "181818" ; "72787E"
EDITCTRLBACKGROUND := "1F1F1F" ; "1F1F1F" ; "303841"

RELATIVEPATHSIGN := "\"
DEFINITIONDELIMITER := "><"
INIDELIMITER := "|#@$::$@#|"

eVALUETYPE := {Variable: 0, Literal: 1, Invalid: 2}
ePARSEMODE := {Command:0, ConstField: 1, EnumField: 2, OthersField: 3}
ePARAMSPARSETYPE := {Invalid: 0, Normal: 1, OutputArgument: 2, InputArgument: 3}
eEXITERRORCODES := {
    InsufficientParamCount: 1, 
    InvalidInputSourceCode: 2,
    InvalidSannyBuilderDirectory: 3,
    InvalidGame: 4,
    InvalidOutputSourceCode: 5,
    ConversionFailed: 6,
    FailedOverwriteOutputFile: 7,
    FailedCreateOutputFile: 8
}
eWARNINGCODES := Map(
    "OpenFileFailed", "File is missing or it's locked used by another process",
    "InvalidOpcode", "Used by Developers to detect problems",
    "DetectParamsFailed", "    Failed to detect all parameters of a command, or the command itself isn't provided by the list of {$USE} extensions. Can be fixed by:`n        1) Providing {$USE <command's extension>} code declaration.`n        2) Providing {$INCLUDE <constant parameter's filepath>} code declaration of all external constants file to resolve all unknown parameters specified for this command.`n        3) All {$INCLUDE} filepaths must specified as well at this Tool's Settings -> Constants/Enums Files.",
    "InvalidParameter", "A detected parameter from a command might be causing a syntax error in Sanny Builder. Check its value if it's an Unknown Reference, or is causing Circular Referencing",
    "PropMissing", "A command in SBL's json file has a certain property that is missing. Used by Developers to detect problems.",
    "UnequalParams", "A command in SBL's json file has unequal parameter count. Used by Developers to detect problems.",
    "OpcodeUntraceable", "SCM opcode is missing in SBL. Used by Developers to detect problems.",
    "DuplicateDefinitions", "two or more duplicate definitions of the subject was detected. Used by Developers to detect problems."
)

REGEXBOUNDEDCOMMENT := "{.*?}|\/\*.*?\*\/"
REGEXALLCOMMENTS := REGEXBOUNDEDCOMMENT . "|\/{2}.*"
REGEXCOMMENTSANDSPACES := "(?:[ \t]*(?:" . REGEXALLCOMMENTS . "))*[ \t]*"
REGEXAVOIDBODYCOMMENTS     := "(?:[ \t]*(?:" . REGEXBOUNDEDCOMMENT . "))*"
;REGEXENDOFWORD := "(?:[ \t]|$)"
REGEXIGNOREINICOMMENTS := "^[ \t]*[^;#\/]*[ \t]*"
REGEXLEFTHANDSIDE := "^(\w+?)[ \t]*="
REGEX_PARSE_EQUALITY := REGEXLEFTHANDSIDE . "[ \t]*(.+?)[ \t]*$"
REGEX_PARSE_INLINEDDECLARATIONS_CONSTANT := "(\w+)[ \t]*=[ \t]*([\w@$(),\[\]]+)[ \t]*(?:,|$)"
REGEX_PARSE_INLINEDDECLARATIONS_AUTOASSIGNEDVARIABLE := "(\w+[ \t]*=[ \t]*[\w@$(),\[\]]+)[ \t]*(?:,|$)"
REGEX_PARSE_MULTICONST := "i)^const[ \t]+(.*)$"
REGEXENUMNAME := "i)^enum[ \t]+(.+)$"
REGEXOPTIONALARRAY := "(?:\[.+?\]|\(.+?,.+?\))?"
REGEXLVAR := "\d+?@[SsVv]?" ; Local Variable
REGEXGVAR := "[SsVv]?\$\w+?" ; Global Variable
REGEXVARARRAY := "^(?:" . REGEXLVAR . "|" . REGEXGVAR . ")" . REGEXOPTIONALARRAY . "$"
REGEXLITERALS := "^(?:" . "[@#]\w+?" ; Label/Model Name
         . "|" . "`".*?`"" ; Long String
         . "|" . "'.*?'" ; Short String  or Ascii Character
         . "|" . "0[xXbB][[:xdigit:]]+?" ; Hexadecimal/Binary Integer
         . "|" . "[+-]?(?:\d*?\.\d+?|\d+)(?:e[+-]?\d+)?" . ")$" ; decimal integer/float with/without exponential notation
; #endregion Constants

gSettings := LoadSettings()

if (A_Args.Length >= 2) { ; User is interacting to this script via CMD
    /*
        A_Args[1] = Input Source Code
        A_Args[2] = Sanny Builder Directory
        A_Args[3] = Target Game
        A_Args[4] = UseClass (Optional Parameter)
        A_Args[5] = Output Source Code (Optional Parameter)
    */

    if (A_Args.Length < 3) { ; 3 params minimum
        ExitApp eEXITERRORCODES.InsufficientParamCount
    }
    
    loop A_Args.Length {
        A_Args[A_Index] := StrReplace(A_Args[A_Index], '"') ; replace all quotation marks
    }

    CLIProcessSourceCode(A_Args*)
}

gHighlightedRegions := Array(Map(), Map())
gConvertedText := Array("", "")
if gSettings.UseClassicEdit { ; classic edit control is preferred
    useRichEdit := false
} else try useRichEdit := DllCall("LoadLibrary", "Str", "msftedit", "Ptr")
catch {
    useRichEdit := false
}

; #region ~~~~~~~~~~~~~~~~~~~~~~~~~~~ Construct the Control Panel GUI
Gui_ControlPanel := Gui("Resize OwnDialogs Disabled", Gui_ControlPanel_DefaultTitle)
Gui_ControlPanel.BackColor := GUIBACKGROUND
Gui_ControlPanel.SetFont("s" . GUIFONTSIZE . " c" . GUITEXTCOLOR, GUIFONTNAME)
Gui_ControlPanel.AddTab3("vTabs", ["Main", "Settings"]).SetFont("bold")

Gui_ControlPanel["Tabs"].UseTab(1)  ; Add Controls at the Main Tab
Gui_ControlPanel.AddText("X30 Y50", "Game:")
Gui_ControlPanel.AddDDL("X+2 H20 W50 vGame R" . gSettings.Games.Length . " Choose" . gSettings.Game, gSettings.Games).OnEvent("Change", GameChanged)
Gui_ControlPanel.AddCheckBox("X+m H20 vUseClass Checked" . gSettings.UseClass, "Use Class").OnEvent("Click", ViewModeChanged)
if useRichEdit {
    Gui_ControlPanel.AddCheckBox("X+m H20 vHighlightDetectedCommands Checked" . gSettings.HighlightDetectedCommands, "Highlight Detected Commands").OnEvent("Click", ViewModeChanged)
}
Gui_ControlPanel.AddButton("X+m H20", "Save Converted Source Code").OnEvent("Click", SaveConvertedText)
Gui_ControlPanel.AddButton("X30 Y+10 H20 vBrowseSC", "Browse Source Code").OnEvent("Click", BrowseSourceCode)
Gui_ControlPanel.AddEdit("X+m W480 H20 vTargetPath ReadOnly Background" . EDITCTRLBACKGROUND)
if !useRichEdit { ; msftedit.dll is not loaded
    Gui_ControlPanel.AddEdit("X30 Y+10 W1130 H200 vConvertedText ReadOnly Background" . EDITCTRLBACKGROUND) ; create classic edit control
} else {
    try Gui_ControlPanel.AddCustom("X30 Y+10 W1130 H200 vConvertedText ClassRichEdit50W 0x800 0x4 0x200000")
    catch { ; failsed to create richedit control
        useRichEdit := false
        Gui_ControlPanel.AddEdit("X30 Y+10 W1130 H200 vConvertedText ReadOnly Background" . EDITCTRLBACKGROUND) ; create classic edit control
    }
    else { ; richedit control has been sucessfully created
        RichEdit_SetBackgroundColor(Gui_ControlPanel["ConvertedText"], ("0x" . EDITCTRLBACKGROUND) + 0)
        RICHEDITHEADER := RichEdit_ConstructHeader(
            GUIFONTNAME,
            GUIFONTSIZE,
            ("0x" . GUITEXTCOLOR) + 0,
            [
                0x00FF00, ; Good
                0xFF0000, ; Error
                0xFFFF00  ; Var Declation
            ]
        )
    }
}
Gui_ControlPanel.AddEdit("X680 Y35 W480 H73 vWarnings ReadOnly Background" . EDITCTRLBACKGROUND).SetFont("s8")

Gui_ControlPanel["Tabs"].UseTab(2)  ; Add Controls at the Settings Tab
Gui_ControlPanel.AddButton("X30 Y50 H20", "Browse Sanny Builder").OnEvent("Click", BrowseSannyBuilder)
Gui_ControlPanel.AddEdit("X+m W780 H20 vSBDir ReadOnly Background" . EDITCTRLBACKGROUND, gSettings.SBDir)
Gui_ControlPanel.AddCheckBox("X+m H20 vUseClassicEdit Checked" . gSettings.UseClassicEdit, "Use Classic Textbox").OnEvent("Click", EditControlTypeChanged)
Gui_ControlPanel.SetFont("s9")
Gui_ControlPanel.AddText("X30 Y+20", "Configure Definitions Files for")
Gui_ControlPanel.SetFont("s" . GUIFONTSIZE)
Gui_ControlPanel.AddDDL("X+2 W50 H1 vConfigurationGameType R" . gSettings.Games.Length . " Choose" . gSettings.Game, gSettings.Games).OnEvent("Change", ReloadDefinitions)
Gui_ControlPanel.SetFont("s9")
Gui_ControlPanel.AddText("X+2", 'Separate each definitions by a single newline.')
Gui_ControlPanel.AddText("X30 Y+10", 'Specify the full path to file or add backslash "\" at the beginning for Relative Path to SB\data\<game>')
Gui_ControlPanel.AddText("X30 Y+3", 'Put "><" sign at the beginning of comments')
Gui_ControlPanel.SetFont("s" . GUIFONTSIZE . " bold")
Gui_ControlPanel.AddText("X200 Y+10 vConstEnumText_x", "Constants/Enums Files")
Gui_ControlPanel.AddText("X+460 vKeywordsText_x", "Keywords Files")
Gui_ControlPanel.SetFont("norm")
Gui_ControlPanel.AddEdit("X30 Y+10 W560 H125 vConstantsEnumsFilePaths Background" . EDITCTRLBACKGROUND, gSettings.ConstantsEnumsFilePaths[Gui_ControlPanel["ConfigurationGameType"].Text]).OnEvent("LoseFocus", SaveDefinitionSettingToIni)
Gui_ControlPanel.AddEdit("X+10 W560 H125 vKeywordsFilePaths Background" . EDITCTRLBACKGROUND, gSettings.KeywordsFilePaths[Gui_ControlPanel["ConfigurationGameType"].Text]).OnEvent("LoseFocus", SaveDefinitionSettingToIni)

Gui_ControlPanel["Tabs"].UseTab()  ; Add Controls Outside the Tab
Gui_ControlPanel.AddButton("X545 Y5 W100 H15 vVisitIssues", "Visit Issues Page").OnEvent("Click", (*) => run("https://github.com/Aldrin-John-Olaer-Manalansan/SB-SBL_Syntax_Converter/issues"))
Gui_ControlPanel["VisitIssues"].SetFont("s8")

Gui_ControlPanel.OnEvent("DropFiles", DragAndDropFile)
Gui_ControlPanel.OnEvent("Size",Gui_ControlPanel_Resize)
Gui_ControlPanel.OnEvent("Close",Gui_ControlPanel_Closed)
Gui_ControlPanel.Show("Center")

sleep 500
Gui_ControlPanel.Maximize()
Gui_ControlPanel.Opt("-Disabled")
; #endregion

if (A_Args.Length == 1) { ; a file has been dragged onto this script before runtine
    PreloadConvertedText(A_Args[1])
}

; #endregion ~~~~~~~~~~~~~~~~ INITIALIZATION ~~~~~~~~~~~~~~~~~

Return

; #region ~~~~~~~~~~~~~~~~~~~~~~~ HOTKEYS ~~~~~~~~~~~~~~~~~~~~


; #endregion ~~~~~~~~~~~~~~~~~~~~ HOTKEYS ~~~~~~~~~~~~~~~~~~~~

; #region ~~~~~~~~~~~~~~~~~~~~~ HOTSTRINGS ~~~~~~~~~~~~~~~~~~~


; #endregion ~~~~~~~~~~~~~~~~~~ HOTSTRINGS ~~~~~~~~~~~~~~~~~~~

; #region ~~~~~~~~~~~~~~~~~~~~~~~ TIMERS ~~~~~~~~~~~~~~~~~~~~~


; #endregion ~~~~~~~~~~~~~~~~~~~~ TIMERS ~~~~~~~~~~~~~~~~~~~~~

; #region ~~~~~~~~~~~~~~~~~~~ Events Handlers ~~~~~~~~~~~~~~~~
BrowseSannyBuilder(*)
{
	Gui_ControlPanel.Opt("+OwnDialogs")
    SelectSBDir:
    if !(selected := DirSelect(, , "Navigate to Sanny Builder Root Folder")) {
        return
    }
    if !ValidateSBDir(selected) {
        if (MsgBox(
            "Cannot Find the data configuration directories`n`nWould you like to select a folder again?",
            "Invalid Sanny Builder Directory",
            4096 ; Always on top
            + 64 ; Info Icon
            +  4 ; Yes/No Buttons
        ) == "Yes") {
            goto SelectSBDir
        }
        return
    }
    Gui_ControlPanel["SBDir"].Value := selected
    IniWrite(selected, INIPATH, "General", "SBDir")
}

SaveConvertedText(*) {
	Gui_ControlPanel.Opt("+OwnDialogs")
    if (Gui_ControlPanel["ConvertedText"].Text == "")
    or !(selected := FileSelect("S18", , "Select File", "Text (*.txt)")) {
        return
    }
    SplitPath(selected,&name)
    if !InStr(name, ".") {
        selected .= ".txt"
    }
    if FileExist(selected) {
        FileDelete(selected)
    }
    FileAppend(Gui_ControlPanel["ConvertedText"].Text, selected)
    msgbox "Converted Source Code has been saved at:`n" . selected
}

EditControlTypeChanged(*) {
    if (MsgBox(
        "Changing the textBox type requires restart. Please make sure to save your work before proceeding.`n`nContinue?",
        "Confirmation",
        4096 ; Always on top
        + 32 ; Question Icon
        +  4 ; Yes/No Buttons
    ) == "Yes") {
        IniWrite(Gui_ControlPanel["UseClassicEdit"].Value, INIPATH, "General", Gui_ControlPanel["UseClassicEdit"].Name)
        Reload
        sleep 3000
        MsgBox(
            "This program will now exit without restaring. Please manually launch this program after.",
            "Reload Failed",
            4096 ; Always on top
            + 48 ; Exclamation Icon
            +  0 ; OK Button
        )
        ExitApp
    } else {
        Gui_ControlPanel["UseClassicEdit"].Value := !Gui_ControlPanel["UseClassicEdit"].Value ; revert changes
    }
}

GameChanged(*) {
    IniWrite(Gui_ControlPanel["Game"].Value, INIPATH, "General", Gui_ControlPanel["Game"].Name)
    Gui_ControlPanel["ConfigurationGameType"].Value := Gui_ControlPanel["Game"].Value
    ReloadDefinitions()
}

ViewModeChanged(*) {
    IniWrite(Gui_ControlPanel["UseClass"].Value, INIPATH, "General", Gui_ControlPanel["UseClass"].Name)
    scrollBarPos := DllCall("GetScrollPos", "Ptr", Gui_ControlPanel["ConvertedText"].Hwnd, "Int", 1, "Int") ; get vertical scrollbar position
    
    if useRichEdit {
        SetConvertedRichTextControl()
    } else {
        Gui_ControlPanel["ConvertedText"].Text := gConvertedText[Gui_ControlPanel["UseClass"].Value + 1]
    }
    
    SendMessage(
                 0x0115, ; WM_VSCROLL ; tells the control that a scrolling event happened
    (scrollBarPos << 16) ; HIWORD = scrollbar position
    |                 4, ; SB_THUMBPOSITION ; indicate that we dragged the scrollbar to the position then released it
                      0, ; Edit control uses standard scrollbar, therefore NULL
        Gui_ControlPanel["ConvertedText"]
    )
}

SaveDefinitionSettingToIni(GuiCtrlObj, Info := "") {
    ; remove leading and trailing whitespaces then reformat into an ini compatible string (no newlines)
    gSettings.ConstantsEnumsFilePaths[Gui_ControlPanel["ConfigurationGameType"].Text] := Trim(StrReplace(GuiCtrlObj.Value, "/", "\"), " `t`n")
    IniWrite(
        StrReplace(gSettings.ConstantsEnumsFilePaths[Gui_ControlPanel["ConfigurationGameType"].Text], "`n", INIDELIMITER),
        INIPATH,
        Gui_ControlPanel["ConfigurationGameType"].Text,
        GuiCtrlObj.Name
    )
}

ReloadDefinitions(*) {
    Gui_ControlPanel["ConstantsEnumsFilePaths"].Value := gSettings.ConstantsEnumsFilePaths[Gui_ControlPanel["ConfigurationGameType"].Text]
    Gui_ControlPanel["KeywordsFilePaths"].Value := gSettings.KeywordsFilePaths[Gui_ControlPanel["ConfigurationGameType"].Text]
}

BrowseSourceCode(*) {
	Gui_ControlPanel.Opt("+OwnDialogs")
    if selected := FileSelect("3", , "Select Source Code to Convert") {
        GUIProcessSourceCode(selected)
    }
}

DragAndDropFile(GuiObj, GuiCtrlObj, FileArray, X, Y)
{
    if (GuiCtrlObj != Gui_ControlPanel["ConvertedText"]) {
        return
    }
    if Gui_ControlPanel["ConvertedText"].Text
    and (MsgBox(
        "Converting source code:`n" . FileArray[1] . "`n`nThe converted source code field will be updated. Continue?",
        "Confirmation",
        4096 ; Always on top
        + 32 ; Question Icon
        +  4 ; Yes/No Buttons
    ) != "Yes") {
        return
    }
    GUIProcessSourceCode(FileArray[1])
}

Gui_ControlPanel_Resize(GuiObj, MinMax, Width, Height) {
	If (MinMax = -1) ; The window has been minimized.
		Return
	AutoXYWH("wh", Gui_ControlPanel["Tabs"])
	AutoXYWH("w", Gui_ControlPanel["SBDir"])
	AutoXYWH("x", Gui_ControlPanel["UseClassicEdit"])
	AutoXYWH("w", Gui_ControlPanel["Warnings"])
	AutoXYWH("wh", Gui_ControlPanel["ConvertedText"])
	AutoXYWH("x0.25", Gui_ControlPanel["ConstEnumText_x"])
	AutoXYWH("x0.75", Gui_ControlPanel["KeywordsText_x"])
    AutoXYWH("w0.5 h", Gui_ControlPanel["ConstantsEnumsFilePaths"])
    AutoXYWH("x0.5 w0.5 h", Gui_ControlPanel["KeywordsFilePaths"])
    AutoXYWH("x0.5", Gui_ControlPanel["VisitIssues"])
}

Gui_ControlPanel_Closed(*) {
    for , v in ["ConstantsEnumsFilePaths", "KeywordsFilePaths"] {
        SaveDefinitionSettingToIni(Gui_ControlPanel[v])
    }
}
; #endregion ~~~~~~~~~~~~~~~~ Events Handlers ~~~~~~~~~~~~~~~~

; #region ~~~~~~~~~~~~~~~~ SNIPPETS / FUNCTIONS ~~~~~~~~~~~~~~

PreloadConvertedText(sourceCodePath) {
    checker := FileExist(sourceCodePath)
    if checker and !InStr(checker, "D") { ; file exist or is not a folder
        GUIProcessSourceCode(sourceCodePath)
    }
}

RichEdit_SetBackgroundColor(RECtrl, BGR) {
    SendMessage( ; Set Background Color of our RichEdit
        0x0443, ; EM_SETBKGNDCOLOR
             0, ; Use Custom Color from LParam
           BGR, ; 0xBBGGRR
        RECtrl
    )
}

HexToRichEditColorFont(hex) {
    return "\red"   . ((hex >> 16) & 0xFF)
         . "\green" . ((hex >>  8) & 0xFF)
         . "\blue"  . ( hex        & 0xFF) . ";"
}

RichEdit_ConstructHeader(fontName, fontSize, defaultColorFont, colorFontTable) {
    header := "{\rtf1\ansi{\fonttbl{\f0 " . fontName . ";}}{\colortbl" . HexToRichEditColorFont(defaultColorFont) 
    for , colorFont in colorFontTable {
        header .= HexToRichEditColorFont(colorFont) 
    }
    header .= "}\f0\fs" . fontSize * 2 . "\cf0\b0"
    return header
}

SetRTF(RE, RTFString) {
    buf := Buffer(StrPut(RTFString, "UTF-8"))
    StrPut(RTFString, buf, "UTF-8")
    SendMessage(0x000C, 0, buf, RE) ; 0x000C = WM_SETTEXT
}

SetConvertedRichTextControl() {
    viewMode := Gui_ControlPanel["UseClass"].Value + 1
    richText := RICHEDITHEADER
    Loop parse gConvertedText[viewMode], "`n", "`r" {
        if !Gui_ControlPanel["HighlightDetectedCommands"].Value ; command highlighting disabled
        or !gHighlightedRegions[viewMode].Has(A_Index) { ; this text line has no highlighted command
            richText .= RegExReplace(A_LoopField, "[\\{}]", "\$0")
        } else { ; this text line has highlighted command
            leadingText := SubStr(A_LoopField, 1, gHighlightedRegions[viewMode][A_Index].Pos - 1)
            highlightedText := SubStr(A_LoopField, gHighlightedRegions[viewMode][A_Index].Pos, gHighlightedRegions[viewMode][A_Index].Len)
            trailingText := SubStr(A_LoopField, gHighlightedRegions[viewMode][A_Index].Pos + gHighlightedRegions[viewMode][A_Index].Len)
            leadingText := RegExReplace(leadingText, "[\\{}]", "\$0")
            highlightedText := "{\b\cf" . gHighlightedRegions[viewMode][A_Index].CFI . " " . RegExReplace(highlightedText, "[\\{}]", "\$0") . "}"
            trailingText := RegExReplace(trailingText, "[\\{}]", "\$0")
            richText .= leadingText . highlightedText . trailingText
            
        }
        richText .= "{\line}"
    }
    richText .= "}"
    SetRTF(Gui_ControlPanel["ConvertedText"], richText)
}

GUIProcessSourceCode(sourceCodePath) {
    global gConvertedText

	Gui_ControlPanel.Opt("+OwnDialogs")
    if !ValidateSBDir(Gui_ControlPanel["SBDir"].Value) {
        Gui_ControlPanel["Tabs"].Choose(2) ; go to settings panel
        MsgBox(
            "Please browse Sanny Builder Root Directory first",
            "Invalid Sanny Builder Directory",
            4096 ; Always on top
            + 16 ; Cross Icon
            +  0 ; OK Button
        )
        return
    }
        ; disable interation with the GUI
    Gui_ControlPanel.Opt("+Disabled")
    Gui_ControlPanel["UseClass"].Enabled := false
    Gui_ControlPanel["BrowseSC"].Enabled := false
        ; initialize global variables
    Gui_ControlPanel["TargetPath"].Value := sourceCodePath
    Gui_ControlPanel["Warnings"].Value := ""
    Gui_ControlPanel["ConvertedText"].Text := ""
    gConvertedText[1] := ""
    gConvertedText[2] := ""
        ;
        ; initialize local variables
    highlightText := !useRichEdit ? false : Gui_ControlPanel["HighlightDetectedCommands"].Value
        ;
    InitializeVariables(Gui_ControlPanel["SBDir"].Value, Gui_ControlPanel["Game"].Text)
    gConvertedText[Gui_ControlPanel["UseClass"].Value + 1] := ConvertSBToSBL(sourceCodePath, Gui_ControlPanel["Game"].Text, Gui_ControlPanel["UseClass"].Value, true, highlightText)
    if useRichEdit {
        SetConvertedRichTextControl()
    } else {
        Gui_ControlPanel["ConvertedText"].Text := gConvertedText[Gui_ControlPanel["UseClass"].Value + 1]
    }
    Gui_ControlPanel.Opt("-Disabled") ; enable interation with the GUI except the operation buttons
        ; wait for the alternative converted text view to finish before reenabling the operation buttons
    gConvertedText[!Gui_ControlPanel["UseClass"].Value + 1] := ConvertSBToSBL(sourceCodePath, Gui_ControlPanel["Game"].Text, !Gui_ControlPanel["UseClass"].Value, false, highlightText)
        ; reenable operation buttons
    Gui_ControlPanel["UseClass"].Enabled := true
    Gui_ControlPanel["BrowseSC"].Enabled := true
}

CLIProcessSourceCode(inputSourceCode, sannyBuilderDirectory, targetGame, useClass := "", outputSourceCode := "", unused*) {

    checker := FileExist(inputSourceCode)
    if !checker or InStr(checker, "D") { ; file does not exist or is a folder
        ExitApp eEXITERRORCODES.InvalidInputSourceCode
    }

        ; remove trailing slash/backslash
    checker := SubStr(sannyBuilderDirectory, -1, 1) ; get last character
    if (checker == "\") or (checker == "/") {
        sannyBuilderDirectory := SubStr(sannyBuilderDirectory, 1, -1) ; remove the last character
    }
        ;
    checker := FileExist(sannyBuilderDirectory . "\")
    if !checker or !InStr(checker, "D") or !ValidateSBDir(sannyBuilderDirectory) { ; folder is invalid
        ExitApp eEXITERRORCODES.InvalidSannyBuilderDirectory
    }
    
        ; check if the specified game has SBL data
    checker := true
    for , folderName in gSettings.Games {
        if (targetGame != folderName) {
            continue
        }
        dataDir := sannyBuilderDirectory . "\data\" . folderName
        if FileExist(dataDir . "\") and FileExist(dataDir . "_sbl\") {
            checker := false
            break
        }
    }
    if checker {
        ExitApp eEXITERRORCODES.InvalidGame
    }
        ;
    if !outputSourceCode or (inputSourceCode == outputSourceCode) { ; output source code has been specified
        ; construct a unique output path that doesn't exist yet
        SplitPath(inputSourceCode, , &dir, &ext, &name)
        outputSourceCode := dir . "\" . name . "_SBL." . ext
        while FileExist(outputSourceCode) {
            outputSourceCode := dir . "\" . name . "_SBL" . A_Index . "." . ext
        }
    }
    
    useClass := (useClass == "") ? gSettings.UseClass : useClass ? true : false

    InitializeVariables(sannyBuilderDirectory, targetGame)
    convertedText := ConvertSBToSBL(inputSourceCode, targetGame, useClass, false)
    if (convertedText == "") {
        ExitApp eEXITERRORCODES.ConversionFailed
    } else {
        if FileExist(outputSourceCode) {
            try FileDelete(outputSourceCode)
            catch {
                ExitApp eEXITERRORCODES.FailedOverwriteOutputFile
            }
        }
        if !FileExist(outputSourceCode) {
            try FileAppend(convertedText, outputSourceCode)
            catch {
                ExitApp eEXITERRORCODES.FailedCreateOutputFile
            }
        }
    }

    ExitApp ; successful exit
}

ValidateSBDir(sbDir) {
    for , folderName in gSettings.Games {
        dataDir := sbDir . "\data\" . folderName
        if !FileExist(dataDir . "\") or !FileExist(dataDir . "_sbl\" . folderName . ".json") {
            return false
        }
    }
    return true
}

LoadSettings() {
    if (!FileExist(INIPATH)) {
        FileAppend("", INIPATH)
        isNewIni := true
    } else {
        isNewIni := false
    }

    settings := Object()

        ; Load all General Settings
    for , el in [
        ["Games", "gta3|sa|vc"],
        ["Game", "2"],
        ["UseClass", "1"],
        ["HighlightDetectedCommands", "1"],
        ["UseClassicEdit", "0"],
        ["SBDir", ""] ] {
        settings.%el[1]% := IniRead(INIPATH, "General", el[1], "")
        if (settings.%el[1]% == "") and (el[2] != "") { ; key is undefined
            settings.%el[1]% := el[2]
            IniWrite(el[2], INIPATH, "General", el[1])
        }
    }
    settings.Games := StrSplit(settings.Games, "|", " `t")
        ;

        ; Load all Constants/Enums/Keywords FilePaths
    for , el in ["ConstantsEnumsFilePaths", "KeywordsFilePaths"] {
        settings.%el% := Map()
        for , game in settings.Games {
            if !isNewIni  {
                settings.%el%[game] := IniRead(INIPATH, game, el, "")
            } else if (game = "sa") and (el == "ConstantsEnumsFilePaths") {
                ; add SAMPFUNCS constants if ini is new
                settings.%el%[game] := RELATIVEPATHSIGN . "SF " . DEFINITIONDELIMITER . " Extensionless file containing all SAMPFUNCS Legacy Constants manually added at <SBDir>\data\<game>\"
                IniWrite(settings.%el%[game], INIPATH, game, el)
            } else {
                settings.%el%[game] := ""
            }
            settings.%el%[game] := Trim(StrReplace(settings.%el%[game], INIDELIMITER, "`n"), " `t`n")
        }
    }
        ;

    return settings
}

InitializeVariables(sannyBuilderDir, game, ignoreDuplicateKeywords := true, ignoreComments := true) {
    global scmCommandsMap, sblCommandsMap, dataTypesMap, predefinedDeclarations, predefinedKeywords, sblVersion

    warning := ""
    workPath := sannyBuilderDir . "\data\" . game

    sblCommandsMap := Map()
    json := FileRead(workPath . "_sbl\" . game . ".json")
    json := Jxon_load(&json)
    sblVersion := (json.Has("meta") and json["meta"].Has("version")) ? json["meta"]["version"] : "Unknown"
    For extension in json["extensions"] {
        if !extension.Has("name") or !extension.Has("commands") {
            continue
        }
        extensionName := StrLower(extension["name"])
        sblCommandsMap[extensionName] := Map()
        For command in extension["commands"] {
            opcode := ("0x" . command["id"]) + 0 ; convert hex string to number
            if (opcode == "") { ; failed parsing opcode
                warning .= "InvalidOpcode: sa.json/" . extension["name"] . "/" . (command.Has("name")?command["name"]:"<UNKNOWN>") . "`n"
                continue
            }

            if sblCommandsMap[extensionName].Has(opcode) {
                warning .= "DuplicateDefinitions: Command -> sa.json/" . extension["name"] . "/" . Format("{:04X}", opcode) . " -> (" . sblCommandsMap[extension["name"]][opcode]["name"] . " | " . command["name"] . ")`n"
            }

            if !command.Has("num_params") {
                warning .= "PropMissing: num_params -> sa.json/" . extension["name"] . "/" . Format("{:04X}", opcode) . "`n"
            } else if (command["num_params"] != ((command.Has("input")?command["input"].Length:0) + (command.Has("output")?command["output"].Length:0))) {
                warning .= "UnequalParams: num_params != num_outputs + num_inputs -> sa.json/" . extension["name"] . "/" . Format("{:04X}", opcode) . "`n"
            }

            sblCommandsMap[extensionName][opcode] := command
        }
    }

        ; get all possible datatypes
    dataTypesMap := Map("int", true, "float", true, "string", true) ; initialize map and default values
    for , extension in sblCommandsMap {
        for , command in extension {
            if command.Has("class") and !dataTypesMap.Has(command["class"]) {
                dataTypesMap[command["class"]] := true ; add this class name to our list of known datatypes
            }
            for key in ["input", "output"] {
                if !command.Has(key) {
                    continue
                }
                for , element in command[key] {
                    if element.Has("type") and !dataTypesMap.Has(element["type"]) {
                        dataTypesMap[element["type"]] := true ; add this data type to our list of known datatypes
                    }
                }
            }
        }
    }
        ;

        ; get the list of ini extension names
    scmIniExtensions := Map()
    loop files workPath . "\" . game . "SCM*.ini" {
        scmIniName := A_LoopFileName
        posL := InStr(scmIniName,".")
        posR := InStr(scmIniName,".", , -1)
        if (posL == posR) {
            extensionName := "default"
        } else {
            posL++
            extensionName := StrLower(SubStr(scmIniName, posL, posR-posL))
        }
        scmIniExtensions[extensionName] := true
    }
        ;
    RegExSCMParser := (ignoreComments?REGEXIGNOREINICOMMENTS:"") . "([[:xdigit:]]{4})[ \t]*=[ \t]*(-?\d+?),(.+)"
    scmCommandsMap := Map()
    loop files workPath . "\" . game . "SCM*.ini" {
        try fileObj := FileOpen(A_LoopFileFullPath, "r")
        catch {
            warning .= "OpenFileFailed: " A_LoopFileFullPath . "`n"
            continue
        }
        scmIniName := A_LoopFileName
        posL := InStr(scmIniName,".")
        posR := InStr(scmIniName,".", , -1)
        if (posL == posR) {
            loopExtensionName := "default"
        } else {
            posL++
            loopExtensionName := StrLower(SubStr(scmIniName, posL, posR-posL))
        }
        while !fileObj.AtEOF {
            textLine := fileObj.ReadLine()
            if !RegExMatch(textLine, RegExSCMParser, &matchedText) {
                continue
            }
            opcode := ("0x" . matchedText[1]) + 0 ; convert hex string to number
            if (opcode == "") { ; failed parsing opcode
                warning .= "InvalidOpcode: " . scmIniName . ":" . textLine "`n"
                continue
            }
                ; organize the opcodes of each extensions in scm to be like sbl extension. Example:
                ; * bitwise opcodes are in default extensions in scm, but in sbl it is a separate extension
                ; * ini, file opcodes are in cleo extensions in scm, but in sbl they are a separate extension
            extensionName := ""
            if sblCommandsMap.Has(loopExtensionName) and sblCommandsMap[loopExtensionName].Has(opcode) {
                extensionName := loopExtensionName
            } else for sblExtensionName in sblCommandsMap {
                if !scmIniExtensions.Has(sblExtensionName) and sblCommandsMap[sblExtensionName].Has(opcode) {
                    ; scm doesn't have an ini extension name with this sbl extension name that has the opcode.
                    extensionName := sblExtensionName
                    break
                }
            }
            if (extensionName == "") {
                warning .= "OpcodeUntraceable: " loopExtensionName "/" Format("{:04X}", opcode) "`n"
                continue
            }
                ;
            if !scmCommandsMap.Has(extensionName) {
                scmCommandsMap[extensionName] := Map()
            }
            scmCommandsMap[extensionName][opcode] := {ParamCount: matchedText[2], ParamOrder: Map()}
            posL := 1
            while (posL := RegExMatch(matchedText[3], "%(\d+)", &orderMatch, posL)) {
                posL += orderMatch.Len

                scmCommandsMap[extensionName][opcode].ParamOrder[orderMatch[1] + 0] := scmCommandsMap[extensionName][opcode].ParamOrder.Count + 1
            }
        }
    }

    predefinedDeclarations := Map()
        ; constants which doesn't require {$include}
    for , filePath in [RELATIVEPATHSIGN . "constants.txt", RELATIVEPATHSIGN . "enums.txt"] {
        warning .= UpdatePredefinedDeclarations(predefinedDeclarations, filePath, workPath, false)
    }
        ; constants which requires {$include}
    if gSettings.ConstantsEnumsFilePaths[game] {
        Loop Parse gSettings.ConstantsEnumsFilePaths[game], "`n", " `t" {
            warning .= UpdatePredefinedDeclarations(predefinedDeclarations, A_LoopField, workPath, true)
        }
    }
        ; no need to verify invalid constants for now, we will process these invalid constants later
    
    predefinedKeywords := Map()
    parsedText := RELATIVEPATHSIGN . "keywords.txt"
    if gSettings.KeywordsFilePaths[game] {
        parsedText .= "`n" . gSettings.KeywordsFilePaths[game]
    }
    Loop Parse parsedText, "`n", " `t" {
        filePath := ((SubStr(A_LoopField, 1, 1) == RELATIVEPATHSIGN) ? workPath : "") . A_LoopField
            ; Remove Comments
        posL := InStr(filePath, DEFINITIONDELIMITER)
        if posL {
            filePath := SubStr(filePath, 1, posL-1)
        }
            ;
        filePath := Trim(filePath) ; remove trailing and leading whitespaces

        try fileObj := FileOpen(filePath, "r")
        catch {
            warning .= "OpenFileFailed: keywords -> " . filePath . "`n"
            continue
        }
        while !fileObj.AtEOF {
            textLine := fileObj.ReadLine()
            if RegExMatch(textLine, REGEXIGNOREINICOMMENTS . "([[:xdigit:]]{4})[ \t]*=[ \t]*(.+)", &matchedText) {
                keyword := StrLower(matchedText[2])
                if !ignoreDuplicateKeywords and predefinedKeywords.Has(keyword) {
                    warning .= "DuplicateDefinitions: keywords.txt/" . keyword . " -> (" . Format("{:04X}", predefinedKeywords[keyword]) . " | " . matchedText[1] . ")`n"
                }
                predefinedKeywords[keyword] := ("0x" . matchedText[1]) + 0 ; add keyword to our list of known keywords
            }
        }
    }

    if IsSet(Gui_ControlPanel) {
        ShowWarnings(warning)
    }
}

ShowWarnings(warnings, overwrite := false) {
    legend := ""
    for key in eWARNINGCODES {
        if InStr(warnings, key) {
            legend .= "`n" . key ": " . eWARNINGCODES[key]
        }
    }
    if legend {
        warnings .= "`n`n~~~Warning Descriptions~~~" . legend . "`n`nCheck this tool's Github Issue page for possible fixes."
    }
    if overwrite {
        Gui_ControlPanel["Warnings"].Value := warnings
    } else {
        Gui_ControlPanel["Warnings"].Value .= warnings
    }
}

ProcessParamsParseType(extension, opcode, params, isLogicNot) {
    scmCommand := scmCommandsMap[extension][opcode]
    sblCommand := sblCommandsMap[extension][opcode]
    if sblCommand.Has("output") and sblCommand["output"][sblCommand["output"].Length].Has("type")
    and (sblCommand["output"][sblCommand["output"].Length]["type"] == "arguments") {
        return {ParseType: ePARAMSPARSETYPE.OutputArgument, IsLogicNot: isLogicNot, SCM: scmCommand, SBL: sblCommand}
    } else if sblCommand.Has("input") and sblCommand["input"][sblCommand["input"].Length].Has("type")
    and (sblCommand["input"][sblCommand["input"].Length]["type"] == "arguments") {
        return {ParseType: ePARAMSPARSETYPE.InputArgument, IsLogicNot: isLogicNot, SCM: scmCommand, SBL: sblCommand}
    } else if (params.Length == sblCommand["num_params"]) {
        return {ParseType: ePARAMSPARSETYPE.Normal, IsLogicNot: isLogicNot, SCM: scmCommand, SBL: sblCommand}
    }
    if (opcode == 0x0AB9) {
        val := true
    }
}

GetParamsParseType(usedExtensions, opcode, params) {
    if (opcode >= 0x8000) {
        isLogicNot := true
        opcode &= 0x7FFF ; flip the not bit
    } else {
        isLogicNot := false
    }
    variantsCount := 0
    for key, extension in sblCommandsMap {
        if extension.Has(opcode) {
            variantsCount++
            extensionName := key
        }
    }
    if (variantsCount == 0) {
        return ; invalid opcode
    } else if (variantsCount == 1) { ; this opcode is unique
        return ProcessParamsParseType(extensionName, opcode, params, isLogicNot)
    } else for extensionName in usedExtensions { ; we strictly require {$USE <extension>}
        if !scmCommandsMap.Has(extensionName) or !scmCommandsMap[extensionName].Has(opcode)
        or !sblCommandsMap.Has(extensionName) or !sblCommandsMap[extensionName].Has(opcode) or !sblCommandsMap[extensionName][opcode].Has("num_params") {
            continue ; this variant is not compatible for our opcode
        }
        if IsObject(command := ProcessParamsParseType(extensionName, opcode, params, isLogicNot)) {
            return command
        }
    }
}

CheckAutoAssignedVariables(declarationsMap, inlinedDeclarations) {
    if !RegExMatch(inlinedDeclarations, "(.+?)[ \t]+(.+)$", &inlinedDeclarations) ; datatype name was not detected
    or !dataTypesMap.Has(inlinedDeclarations[1]) { ; invalid datatype
        return false ; invalid declaration
    }
    inlinedDeclarations := inlinedDeclarations[2]
    ; parses each field separated by comma: dVar1 = 3, dVar2, dVar3 = dVar1, dVar4 = var
    pos := 1
    while (pos := RegExMatch(inlinedDeclarations, REGEX_PARSE_INLINEDDECLARATIONS_AUTOASSIGNEDVARIABLE, &value, pos)) {
        pos += value.Len

        value := value[1]
        if RegExMatch(value, REGEX_PARSE_EQUALITY, &equation) { ; parses value[1] as "equation[1] = equation[2]"
            declarationsMap[equation[1]] := {Value: equation[2], ValueType: eVALUETYPE.Variable}
        } else {
            declarationsMap[value] := {Value: "?", ValueType: eVALUETYPE.Variable} ; declaration is a variable, ? = autoassigned
        }
    }
    return true
}

TraceDeclarationIndirectReference(declarationsMap, name) {
    valueInfo := declarationsMap[name] ; initially evaluate our target declaration name
        ; circular reference detection variables
    originalValue := valueInfo.Value
    isInitialIndirectCheck := true
        ;
    ReevaluateDeclaration:
    ; valueType = 0 = variable
    ; valueType = 1 = literal
    ; valueType = 2 = invalid
    if RegExMatch(valueInfo.Value, REGEXVARARRAY) {
        ; declaration's value is a variable
        if (valueInfo.ValueType != eVALUETYPE.Variable) { ; ValueType isn't correct, maybe previously invalid
            valueInfo.ValueType := eVALUETYPE.Variable
        }
    } else if RegExMatch(valueInfo.Value, REGEXLITERALS) {
        ; declaration's value is literal
        if (valueInfo.ValueType != eVALUETYPE.Literal) { ; ValueType isn't correct, maybe previously invalid
            valueInfo.ValueType := eVALUETYPE.Literal
        }
    } else  { ; try to retrieve the actual value(variable or literal) from multi-indirect declaration
        if isInitialIndirectCheck or (originalValue != valueInfo.Value) { ; indirect declaration aren't performing a circular reference
            isInitialIndirectCheck := false
            if declarationsMap.Has(valueInfo.Value) { ; current declaration's value is equal to another declaration's value (indirect referencing)
                valueInfo := declarationsMap[valueInfo.Value] ; dereference
                goto ReevaluateDeclaration
            }
        }
        ; declaration's value is invalid if it reaches here
        if (valueInfo.ValueType != eVALUETYPE.Invalid) { ; Make sure ValueType is invalid
            valueInfo.ValueType := eVALUETYPE.Invalid
        }
    }
    if (declarationsMap[name] != valueInfo) { ; Was an indirect reference
        declarationsMap[name] := valueInfo ; dereference
    }
}

GetCorrectedDeclaration(declarationsMap, name) { ; get info while also trying to correct detected invalid values
    if (declarationsMap[name].ValueType == eVALUETYPE.Invalid) { ; invalid valueType
        ; try tracing if this declaration is variable or literal
        TraceDeclarationIndirectReference(declarationsMap, name)
    }
    return declarationsMap[name]
}

UpdateEnums(declarationsMap, name, field) {
    if RegExMatch(field, REGEXLEFTHANDSIDE, &matchedText) {
        field := matchedText[1]
    }
    name := StrLower(name) . "." . StrLower(field)
    declarationsMap[name] := {Value: "?", ValueType: eVALUETYPE.Literal} ; enum's value is literal, ? = autoassigned and we dont needed it
}

UpdateConstants(declarationsMap, inlinedDeclarations) {
    ; parses each field separated by comma: c1 = literalconst, c2 = var2, c3 = c2
    pos := 1
    while (pos := RegExMatch(inlinedDeclarations, REGEX_PARSE_INLINEDDECLARATIONS_CONSTANT, &value, pos)) {
        pos += value.Len

        name := StrLower(value[1])
        value := StrLower(value[2])
        if declarationsMap.Has(name) {
            declarationsMap[name].Value := value
            declarationsMap[name].ValueType := eVALUETYPE.Invalid
        } else {
            declarationsMap[name] := {Value: value, ValueType: eVALUETYPE.Invalid}
        }
        TraceDeclarationIndirectReference(declarationsMap, name)
    }
}

UpdatePredefinedDeclarations(predefinedDeclarations, filePath, workPath, requiresInclude := false) {
        ; Remove Comments
    posL := InStr(filePath, DEFINITIONDELIMITER)
    if posL {
        filePath := SubStr(filePath, 1, posL-1)
    }
        ;
    filePath := StrLower(filePath)
    workPath := StrLower(workPath)
    isRelativePath := (SubStr(filePath, 1, 1) == RELATIVEPATHSIGN)
    groupKey := Trim(!requiresInclude ? DEFINITIONDELIMITER : isRelativePath ? SubStr(filePath, 2) : filePath) ; remove trailing and leading whitespaces
    filePath := Trim((isRelativePath ? workPath : "") . filePath) ; remove trailing and leading whitespaces

    try fileObj := FileOpen(filePath, "r")
    catch {
        return "Can't open constants/enums file: " . filePath . "`n"
    }

    if !predefinedDeclarations.Has(groupKey) { ; this group is new from our list of constants groups
        predefinedDeclarations[groupKey] := Map()
    }

    parseMode := 0
    while !fileObj.AtEOF {
        textLine := Trim(RegExReplace(fileObj.ReadLine(), REGEXALLCOMMENTS)) ; remove all comments then remove leading and trailing whitespaces
        if (textLine == "") {
            continue
        } else if parseMode and (textLine = "end") {
            parseMode := ePARSEMODE.Command ; switch to parse command mode
            continue
        }
        switch (parseMode) {
        Case ePARSEMODE.ConstField: ; Const ... End
            UpdateConstants(predefinedDeclarations[groupKey], textLine)
        Case ePARSEMODE.EnumField: ; Enum ... End
            UpdateEnums(predefinedDeclarations[groupKey], enumName, textLine)
        Default: ; Command
            if (textLine = "const") {
                parseMode := ePARSEMODE.ConstField ; switch to parse const mode
            } else if RegExMatch(textLine, REGEXENUMNAME, &matchedText) {
                parseMode := ePARSEMODE.EnumField ; switch to parse enum mode
                enumName := matchedText[1]
            } else if RegExMatch(textLine, REGEX_PARSE_MULTICONST, &matchedText) {
                UpdateConstants(predefinedDeclarations[groupKey], matchedText[1])
            }
        }
    }

    return ""
}

ConvertSBToSBL(inputFile, targetGame, preferClassSyntax := false, printWarnings := true, highlightText := false) {
    global gHighlightedRegions

    try fileReader := FileOpen(inputFile, "r")
    catch {
        return ""
    }

    REGEXCOMMANDSTARTINGBARRIER := "^(?:[ \t]*(?:if|then|else|while|until|" . REGEXALLCOMMENTS . "))*[ \t]*"
    if highlightText {
        gHighlightedRegions[preferClassSyntax + 1] := Map()
    }
    initialComment := "/*"
                    .    "`r`n`tThis Source Code has been converted to SBL using:"
                    .        "`r`n`t`tApplication: " . AppName . " v" . AppVersion.Major . "." AppVersion.Minor . "." AppVersion.Patch
                    .        "`r`n`t`tGame: " . targetGame
                    .        "`r`n`t`tSBL Version: " . sblVersion
                    . "`r`n*/`r`n`r`n"
    StrReplace(initialComment, "`n", , , &lineCount)
    lineCount++ ; if the code starts at the first line, then lineCount = 1 not 0
    convertedText := ""
    warning := ""
    
    usedExtensions := Map()
    declarationsMap := Map()
    for key in predefinedDeclarations[DEFINITIONDELIMITER] { ; add preloaded constants to our list of known constants
        declarationsMap[key] := predefinedDeclarations[DEFINITIONDELIMITER][key]
    }

    parseMode := 0
    while !fileReader.AtEOF {
        if highlightText {
            parsedLineStatus := 0 ; initialize as no highlighting CFI = 0
        }
        textLine := fileReader.ReadLine()
            ; replace breaking changes into their sb4 counterpart
        for , value in [["$player_actor", "$scplayer"], ["$player_char, $player1"]] {
            if InStr(textLine, value[1]) {
                textLine := StrReplace(textLine, value[1], value[2])
            }
        }
            ;
        fromText := RegExReplace(textLine, "\/{2}.*") ; remove // comments
        if InStr(fromText, "{$CLEO") { ; encountered $CLEO directive
            usedExtensions["default"] := true
            usedExtensions["cleo"] := true
        } else if RegExMatch(fromText, "i){[\t ]*\$(USE|I(?:NCLUDE(?:_ONCE)*)*)[\t ]+(.+?)[\t ]*}", &matchedText) { ; encountered $USE directive
            For key in StrSplit(matchedText[2], ",", " `t") {
                key := StrLower(key)
                if (matchedText[1] = "USE") { ; case insensistive
                    if scmCommandsMap.Has(key) and sblCommandsMap.Has(key) {
                        usedExtensions[key] := true
                    }
                } else if predefinedDeclarations.Has(key) { ; process includes
                    for field in predefinedDeclarations[key] { ; add all the constants of this included file to our list of known constants
                        declarationsMap[field] := predefinedDeclarations[key][field]
                    }
                }
            }
        } else if RegExMatch(
            ; remove control-flow commands(if, then, else, while, etc...) to prevent evaluating them as a command
            RegExReplace(fromText, "i)" . REGEXCOMMANDSTARTINGBARRIER),
            "(.+?)" . REGEXCOMMENTSANDSPACES . "$",
            &fromText
        ) {
            ; textLine is suspected as a command (case insensitive)
            fromText := Trim(fromText[1])
            processedText := Trim(RegExReplace(fromText, REGEXBOUNDEDCOMMENT)) ; remove bounded comments in between params

            switch (parseMode) {
            Case ePARSEMODE.ConstField: ; Const ... End
                if (processedText = "end") {
                    parseMode := ePARSEMODE.Command ; switch to parse command mode
                } else {
                    UpdateConstants(declarationsMap, processedText)
                }
            Case ePARSEMODE.EnumField: ; Enum ... End
                if (processedText = "end") {
                    parseMode := ePARSEMODE.Command ; switch to parse command mode
                } else {
                    UpdateEnums(declarationsMap, enumName, processedText)
                }
            Case ePARSEMODE.OthersField: ; Var ... End , Hex ... End
                if (processedText = "end") {
                    parseMode := ePARSEMODE.Command ; switch to parse command mode
                }
            Default: ; Command
                if (processedText = "const") {
                    parseMode := ePARSEMODE.ConstField ; switch to parse const mode
                } else if RegExMatch(processedText, REGEXENUMNAME, &matchedText) {
                    parseMode := ePARSEMODE.EnumField ; switch to parse enum mode
                    enumName := matchedText[1]
                } else if (processedText = "var") or (processedText = "hex") {
                    parseMode := ePARSEMODE.OthersField ; indicate that we are inside a parsing field that we aren't interested
                } else if RegExMatch(processedText, REGEX_PARSE_MULTICONST, &matchedText) { ; const c1 = literalconst, c2 = var2, c3 = c2, ..., ...
                    UpdateConstants(declarationsMap, matchedText[1])
                } else if CheckAutoAssignedVariables(declarationsMap, processedText) { ; <datatype> var1, va2, ...
                    ; declarationsMap now contains all the variables defined by this line
                } else {
                        ; create array of params found at processedText
                    paramOrder := Array()
                    pos := 1
                    while RegExMatch(processedText, "(?:^|[\t ]+)('.+?'|\`".+?\`"|.+?)(?:[\t ]+|$)", &matchedText, pos) { ; match every space separated terms
                        pos := matchedText.Pos(1) + matchedText.Len(1)

                        term := matchedText[1]
                        if (SubStr(term, matchedText.Len(1)) == ":") {
                            continue ; do nothing if its an opcode
                        } else if RegExMatch(term, REGEXVARARRAY) {
                            paramOrder.Push({Value: term, IndirectValue: term, ValueType: eVALUETYPE.Variable}) ; add var to list of params
                        } else if RegExMatch(term, REGEXLITERALS) {
                            paramOrder.Push({Value: term, IndirectValue: term, ValueType: eVALUETYPE.Literal}) ; add literal to list of params
                        } else For constName in declarationsMap {
                            if RegExMatch(term, "i)^(" . StrReplace(constName, ".", "\.") . ")" . REGEXOPTIONALARRAY . "$", &matchedText) { ; term is a constant (case insensitive)
                                declaration := GetCorrectedDeclaration(declarationsMap, constName)
                                paramOrder.Push({Value: matchedText[1], IndirectValue: declaration.Value, ValueType: declaration.ValueType})
                                break
                            }
                        }
                    }
                        ;
                    
                        ; get the opcode and its information that is compatible with the number of detected parameters
                    command := ""
                    if RegExMatch(processedText, "([[:xdigit:]]{4}):", &matchedText) {
                        checkOpcode := ("0x" . matchedText[1]) + 0
                        if !IsObject(command := GetParamsParseType(usedExtensions, checkOpcode, paramOrder)) {
                            if printWarnings {
                                warning .= "DetectParamsFailed: Opcode=" . Format("{:04X}", checkOpcode) . " line=" . lineCount . " text=<<<" textLine ">>>`n"
                            }
                            if highlightText {
                                highlightedText := processedText
                                parsedLineStatus := 2 ; highlight as error encountered during syntax replacement CFI = 2
                            }
                        }
                    } else for key in predefinedKeywords {
                        if RegExMatch(processedText, "i)(?:^|[\t ]+)" . key . "(?:[\t ]+|$)") { ; keyword is used instead of opcode (case-insensitive)
                            if IsObject(command := GetParamsParseType(usedExtensions, predefinedKeywords[key], paramOrder)) {
                                break
                            } else {
                                if printWarnings {
                                    warning .= "DetectParamsFailed: keyword=" . key . " Opcode=" . Format("{:04X}", predefinedKeywords[key]) . " line=" . lineCount . " text=<<<" textLine ">>>`n"
                                }
                                if highlightText {
                                    highlightedText := processedText
                                    parsedLineStatus := 2 ; highlight as error encountered during syntax replacement CFI = 2
                                }
                            }
                        }
                    }
                        ;
                    
                    if IsObject(command) and (command.ParseType != ePARAMSPARSETYPE.Invalid) {
                            ; scm command to sbl command
                        if command.SBL.Has("operator") { ; is an command supports operator syntax
                            processedText := ""
                            ; 1 param total does not need var declaration. So only use var declaration when 2 or 3 params in total.
                            if (command.SBL["num_params"] <= 1) {
                                useOpcodeSyntax := false
                            } else {
                                    ; create a map that enumerates all the variables that needs datatype declaration
                                varMap := Map()
                                index := 0
                                For key in ["input", "output"] {
                                    if !command.SBL.Has(key) or (command.SBL[key].Length <= 0) {
                                        continue
                                    }
                                    For , key in command.SBL[key] {
                                        index++
                                        paramInfo := paramOrder[command.SCM.ParamOrder[index]]
                                        if (paramInfo.ValueType == eVALUETYPE.Invalid) { ; invalid type
                                            if printWarnings {
                                                warning .= "InvalidParameter: param=" paramInfo.Value " line=" . lineCount . " text=<<<" textLine ">>>`n"
                                            }
                                            if highlightText {
                                                parsedLineStatus := 2 ; highlight as error encountered during syntax replacement CFI = 2
                                            }
                                        }
                                        if !key.Has("type")
                                        or (paramInfo.ValueType == eVALUETYPE.Literal) ; is literal string. Variable Type needs declaration. We also declare the variables with invalid types just for user awareness in the generated code
                                        or RegExMatch(paramInfo.Value, "[SsVv]\$|@[SsVv]") { ; this passed value is a string variable
                                            continue
                                        }
                                        if varMap.Has(paramInfo.IndirectValue) { ; last parameter has the highest declaration priority overwriting the old ones
                                            varMap[paramInfo.IndirectValue].Name := paramInfo.Value
                                            varMap[paramInfo.IndirectValue].DataType := key["type"]
                                        } else {
                                            varMap[paramInfo.IndirectValue] := {Name: paramInfo.Value, DataType: key["type"]}
                                        }
                                    }
                                }
                                    ;
                                    ; Enumerate our datatype declarations
                                if (command.SBL["num_params"] == 2) and (varMap.Count == 1) {
                                    useOpcodeSyntax := true
                                } else {
                                    useOpcodeSyntax := false
                                    for , varInfo in varMap {
                                        if (A_Index > 1) {
                                            processedText .= ", "
                                        }
                                        processedText .= varInfo.Name . ":" . varInfo.DataType
                                    }
                                }
                                    ;
                                if (processedText != "") {
                                    processedText := "var " . Trim(processedText,", `t")
                                    if highlightText {
                                        highlightedText := processedText
                                    }
                                    if RegExMatch(textLine, "i)^(" . REGEXCOMMENTSANDSPACES . ")((?:then|else)" . REGEXCOMMENTSANDSPACES . ")", &matchedText) {
                                        ; command is found at the "then" or "else" statement (case insensitive), then we isolate the command
                                        tmpr := matchedText[1] . matchedText[2]
                                        convertedText .= tmpr . "`r`n"
                                        lineCount++
                                        textLine := StrReplace(textLine, tmpr, matchedText[1] . "`t")
                                        processedText := matchedText[1] . "`t" . processedText
                                    } else if RegExMatch(textLine, "^([ \t]+)", &matchedText) { ; append var declaration with indentation
                                        processedText := matchedText[1] . processedText
                                    }
                                    if highlightText {
                                        ; highlight as var declaration (CFI = 3)
                                        gHighlightedRegions[preferClassSyntax + 1][lineCount] := {Pos: InStr(processedText, highlightedText), Len: StrLen(highlightedText), CFI: (parsedLineStatus ? parsedLineStatus : 3)}
                                    }
                                    convertedText .= processedText . "`r`n"
                                    lineCount++
                                    processedText := ""
                                }
                            }
                            ; adding opcode at the beginning for operator commands still the alternative convention: outputs first, inputs last
                            ; so it doesn't actually matter if we put opcode at the beginning or not, cuz the arrangement are the same
                            switch (command.SBL["num_params"]) {
                                case 1:
                                    processedText := command.SBL["operator"] . paramOrder[1].Value
                                case 2:
                                    if (command.SBL.Has("output") and (command.SBL["output"].Length == 1)) { ; use input first output last ordering
                                        processedText := (useOpcodeSyntax ? (command.SBL["id"] . ": ") : "")
                                                       . paramOrder[command.SCM.ParamOrder[2]].Value
                                                       . " " . command.SBL["operator"] . (InStr(command.SBL["operator"],"=")?"":"=") . " "
                                                       . paramOrder[command.SCM.ParamOrder[1]].Value
                                    } else { ; 2 outputs or 2 inputs, therefore we don't need to reorder the parameters
                                        processedText := (useOpcodeSyntax ? (command.SBL["id"] . ": ") : "")
                                                       . paramOrder[command.SCM.ParamOrder[1]].Value
                                                       . " " . command.SBL["operator"] . (InStr(command.SBL["operator"],"=")?"":"=") . " "
                                                       . paramOrder[command.SCM.ParamOrder[2]].Value
                                    }
                                case 3:
                                    processedText := paramOrder[command.SCM.ParamOrder[3]].Value
                                                   . " = "
                                                   . paramOrder[command.SCM.ParamOrder[1]].Value
                                                   . " " . command.SBL["operator"] . " "
                                                   . paramOrder[command.SCM.ParamOrder[2]].Value
                            }
                        } else { ; normal parsing
                            isClassValid := (preferClassSyntax and command.SBL.Has("class") and command.SBL.Has("member"))

                            if isClassValid {
                                processedText := command.SBL["class"] . "." . command.SBL["member"] . "("
                            } else {
                                processedText := StrLower(command.SBL["name"])
                            }
                            index := 0
                            if command.SBL.Has("input") and (command.SBL["input"].Length >= 1) {
                                Loop ((command.ParseType == ePARAMSPARSETYPE.InputArgument) ? paramOrder.Length : command.SBL["input"].Length) {
                                    index++
                                    if !isClassValid {
                                        processedText .= ((
                                            command.SBL["input"].Has(A_Index) and command.SBL["input"][A_Index].Has("name")
                                            and (Trim(command.SBL["input"][A_Index]["name"]) != ""))
                                            ? (" {" . command.SBL["input"][A_Index]["name"] . "} ")
                                            : " ")
                                    } else if (A_Index != 1) {
                                        processedText .= ", "
                                    }
                                    processedText .= paramOrder[(index <= command.SCM.ParamOrder.Count) ? command.SCM.ParamOrder[index] : index].Value
                                }
                            }

                            if (command.ParseType != ePARAMSPARSETYPE.InputArgument)
                            and command.SBL.Has("output") and (command.SBL["output"].Length >= 1) {
                                iterations := ((command.ParseType == ePARAMSPARSETYPE.OutputArgument) ? (paramOrder.Length - (command.SBL.Has("input") ? command.SBL["input"].Length : 0)) : command.SBL["output"].Length)
                                    ; check if user passed a literal value as output param
                                loopIndex := index
                                paramHasLiteralValue := false
                                Loop iterations {
                                    loopIndex++
                                    if paramOrder[(loopIndex <= command.SCM.ParamOrder.Count) ? command.SCM.ParamOrder[loopIndex] : loopIndex].ValueType {
                                        paramHasLiteralValue := true
                                        break
                                    }
                                }
                                    ;
                                if paramHasLiteralValue {
                                    Loop iterations {
                                        index++
                                        if !isClassValid {
                                            processedText .= ((
                                                command.SBL["input"].Has(A_Index) and command.SBL["input"][A_Index].Has("name")
                                                and (Trim(command.SBL["input"][A_Index]["name"]) != ""))
                                                ? (" {" . command.SBL["input"][A_Index]["name"] . "} ")
                                                : " ")
                                        } else if (A_Index != 1) or (command.SBL.Has("input") and (command.SBL["input"].Length >= 1)) { ; has input param specified
                                            processedText .= ", "
                                        }
                                        processedText .= paramOrder[(index <= command.SCM.ParamOrder.Count) ? command.SCM.ParamOrder[index] : index].Value
                                    }
                                } else {
                                    outputText := ""
                                    Loop iterations {
                                        index++
                                        outputText .= ((A_Index == 1)?"":", ")
                                            . paramOrder[(index <= command.SCM.ParamOrder.Count) ? command.SCM.ParamOrder[index] : index].Value
                                    }
                                    processedText := outputText . " = " . processedText
                                }
                            }

                            if isClassValid {
                                processedText .= ")"
                            }

                            if command.IsLogicNot {
                                processedText := "not " . processedText
                            }
                        }
                            ;
                        textLine := StrReplace(textLine, fromText, processedText)
                        if highlightText {
                            highlightedText := processedText
                            if !parsedLineStatus { ; is unhighlighted
                                parsedLineStatus := 1 ; highlight as succesful syntax replacement CFI = 1
                            }
                        }
                    }
                }
            }
        }
        if highlightText and parsedLineStatus {
            ; highlight as var declaration (CFI = 3)
            gHighlightedRegions[preferClassSyntax + 1][lineCount] := {Pos: InStr(textLine, highlightedText), Len: StrLen(highlightedText), CFI: parsedLineStatus}
        }
        convertedText .= textLine . "`r`n"
        lineCount++
    }
    
    if printWarnings and warning and IsSet(Gui_ControlPanel) {
        ShowWarnings(warning)
    }
    if convertedText {
        convertedText := initialComment . convertedText
    }
    return convertedText
}
; #endregion ~~~~~~~~~~~~~ SNIPPETS / FUNCTIONS ~~~~~~~~~~~~~~

; #region ~~~~~~~~~~~~~~~~~~~~~~~ CLASSES ~~~~~~~~~~~~~~~~~~~~

; #endregion ~~~~~~~~~~~~~~~~~~~~ CLASSES ~~~~~~~~~~~~~~~~~~~~

; #region ~~~~~~~~~~~~~~~~~~~~~~ INCLUDES ~~~~~~~~~~~~~~~~~~~~
#include JXON.ahk2 ; https://raw.githubusercontent.com/TheArkive/JXON_ahk2/refs/heads/master/_JXON.ahk
#include AutoXYWH.ahk2 ; https://www.autohotkey.com/boards/viewtopic.php?f=83&t=114445
; #endregion ~~~~~~~~~~~~~~~~~~~ INCLUDES ~~~~~~~~~~~~~~~~~~~~